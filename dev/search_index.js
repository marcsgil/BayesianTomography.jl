var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Prediction","page":"API","title":"Prediction","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"prediction(::Any, ::LinearInversion)\nprediction(::Any, ::BayesianInference)\nLinearInversion\nBayesianInference","category":"page"},{"location":"api/#BayesianTomography.prediction-Tuple{Any, LinearInversion}","page":"API","title":"BayesianTomography.prediction","text":"prediction(outcomes, method::LinearInversion)\n\nPredict the quantum state from the outcomes of a tomography experiment using the LinearInversion method.\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianTomography.prediction-Tuple{Any, BayesianInference}","page":"API","title":"BayesianTomography.prediction","text":"prediction(outcomes, method::BayesianInference{T};\n    verbose=false,\n    σ=T(1e-2),\n    log_prior=x -> zero(T),\n    x₀=maximally_mixed_state(Int(√size(method.povm, 2)), T),\n    nsamples=10^4,\n    nwarm=10^3,\n    chain=nothing) where {T}\n\nPerform a Bayesian inference on the given outcomes using the BayesianInference method.\n\nArguments\n\noutcomes: The outcomes of the experiment.\nmethod::BayesianInference{T}: The Bayesian inference method.\nverbose=false: Print information about the run.\nσ=T(1e-2): The initial standard deviation of the proposal distribution.\nlog_prior=x -> zero(T): The log-prior function.\nx₀=maximally_mixed_state(Int(√size(method.povm, 2)), T): The initial state of the chain.\nnsamples=10^4: The number of samples to take.\nnwarm=10^3: The number of warm-up samples to take.\nchain=nothing: If not nothing, store the chain in this matrix.\n\nReturns\n\nA tuple with the mean state, its projection in method.basis and the covariance matrix. The mean state is already returned in matrix form.\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianTomography.LinearInversion","page":"API","title":"BayesianTomography.LinearInversion","text":"LinearInversion(povm, basis=gell_mann_matrices(size(first(povm), 1)))\n\nConstruct a linear inversion method for quantum state tomography.\n\n\n\n\n\n","category":"type"},{"location":"api/#BayesianTomography.BayesianInference","page":"API","title":"BayesianTomography.BayesianInference","text":"BayesianInference(povm::AbstractArray{Matrix{T}},\n    basis=gell_mann_matrices(size(first(povm), 1), complex(T))) where {T}\n\nCreate a Bayesian inference object from a POVM.\n\nThis is passed to the prediction method in order to perform the Bayesian inference.\n\n\n\n\n\n","category":"type"},{"location":"api/#Augmentation","page":"API","title":"Augmentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"compose_povm\nunitary_transform!\nunitary_transform\naugment_povm","category":"page"},{"location":"api/#BayesianTomography.compose_povm","page":"API","title":"BayesianTomography.compose_povm","text":"compose_povm(povms::AbstractArray{Matrix{T}}...; weights=fill(one(T) / length(povms), length(povms))) where {T}\n\nCompose a POVM (Positive Operator-Valued Measure) from a set of given POVMs.\n\nArguments\n\npovms: Variable number of POVMs. Each POVM is represented as an array of matrices.\nweights: An optional array of weights associated with each POVM. If not provided, it defaults to a uniform distribution.\n\nReturns\n\nA new POVM that is a composition of the input POVMs, weighted by their respective weights.\n\nExample\n\npovm1 = [rand(2,2) for _ in 1:3]\npovm2 = [rand(2,2) for _ in 1:3]\ncomposed_povm = compose_povm(povm1, povm2)\n\n\n\n\n\n","category":"function"},{"location":"api/#BayesianTomography.unitary_transform!","page":"API","title":"BayesianTomography.unitary_transform!","text":"unitary_transform!(povm, unitary)\n\nApply a unitary transformation to each element of a given POVM (Positive Operator-Valued Measure), modifing it in place.\n\nArguments\n\npovm: The POVM to be transformed. It is represented as an array of matrices.\nunitary: The unitary matrix representing the transformation to be applied.\n\nExample\n\nbs_povm = [[1.0+im 0; 0 0], [0 0; 0 1]]\nhalf_wave_plate = [1 1; 1 -1] / √2\nunitary_transform!(bs_povm, half_wave_plate)\n\n\n\n\n\n","category":"function"},{"location":"api/#BayesianTomography.unitary_transform","page":"API","title":"BayesianTomography.unitary_transform","text":"unitary_transform(povm, unitary)\n\nApply a unitary transformation to each element of a given POVM (Positive Operator-Valued Measure).\n\nArguments\n\npovm: The POVM to be transformed. It is represented as an array of matrices.\nunitary: The unitary matrix representing the transformation to be applied.\n\nReturns\n\nA new POVM that is the result of applying the unitary transformation to the input POVM.\n\nExample\n\nbs_povm = [[1.0+im 0; 0 0], [0 0; 0 1]]\nhalf_wave_plate = [1 1; 1 -1] / √2\nunitary_transform!(bs_povm, half_wave_plate)\n\n\n\n\n\n","category":"function"},{"location":"api/#BayesianTomography.augment_povm","page":"API","title":"BayesianTomography.augment_povm","text":"augment_povm(povm::AbstractArray{Matrix{T}}, unitaries...; \n    weights=fill(one(T) / (length(unitaries) + 1), length(unitaries) + 1) where {T}\n\nAugment a POVM (Positive Operator-Valued Measure) by applying a set of unitary transformations to it.\n\nArguments\n\npovm: The POVM to be augmented. It is represented as an array of matrices.\nunitaries: Variable number of unitary matrices representing the transformations to be applied.\nweights: An optional array of weights associated with each unitary transformation. If not provided, it defaults to a uniform distribution.\n\nReturns\n\nA new POVM that is the result of applying the unitary transformations to the input POVM.\n\nExample\n\nbs_povm = [[1.0+im 0; 0 0], [0 0; 0 1]]\nhalf_wave_plate = [1 1; 1 -1] / √2\nquater_wave_plate = [1 im; im 1] / √2\npovm = augment_povm(bs_povm, half_wave_plate, quater_wave_plate, weights=[1 / 2, 1 / 4, 1 / 4])\n\n\n\n\n\n","category":"function"},{"location":"api/#Generalized-Gell-Mann-matrices","page":"API","title":"Generalized Gell-Mann matrices","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"triangular_indices\nX_matrix\nY_matrix\nZ_matrix\ngell_mann_matrices\nbasis_decomposition","category":"page"},{"location":"api/#BayesianTomography.triangular_indices","page":"API","title":"BayesianTomography.triangular_indices","text":"triangular_indices(d)\n\nGenerate a vector of tuples representing the indices of the lower triangular part of a square matrix of dimension d.\n\n\n\n\n\n","category":"function"},{"location":"api/#BayesianTomography.X_matrix","page":"API","title":"BayesianTomography.X_matrix","text":"X_matrix(j, k, d, ::Type{T}=ComplexF32) where {T<:Union{Real,Complex}}\n\nCompute the real off diagonal matrix of the generalized Gell-Mann matrices in dimension d.\n\nThe type of the matrix elements is T, which defaults to ComplexF32. The only non-zero elements are X[j, k] = 1 and X[k, j] = 1. The matrices are normalized to have unit Hilbert-Schmidt norm.\n\nExamples\n\njulia> X_matrix(1,2,2)\n2×2 Matrix{ComplexF32}:\n      0.0+0.0im  0.707107+0.0im\n 0.707107+0.0im       0.0+0.0im\n\n\n\n\n\n","category":"function"},{"location":"api/#BayesianTomography.Y_matrix","page":"API","title":"BayesianTomography.Y_matrix","text":"Y_matrix(j, k, d, ::Type{T}=ComplexF32) where {T<:Complex}\n\nCompute the imaginary off diagonal matrix of the generalized Gell-Mann matrices in dimension d.\n\nThe type of the matrix elements is T, which defaults to ComplexF32. The only non-zero elements are Y[j, k] = im and Y[k, j] = -im. The matrices are normalized to have unit Hilbert-Schmidt norm.\n\nExamples\n\njulia> Y_matrix(1,2,2)\n2×2 Matrix{ComplexF32}:\n 0.0+0.0im       0.0+0.707107im\n 0.0-0.707107im  0.0+0.0im\n\n\n\n\n\n","category":"function"},{"location":"api/#BayesianTomography.Z_matrix","page":"API","title":"BayesianTomography.Z_matrix","text":"Z_matrix(j, d, ::Type{T}=ComplexF32) where {T<:Union{Real,Complex}}\n\nCompute the j'th diagonal matrix of the generalized Gell-Mann matrices in dimension d.\n\nThe type of the matrix elements is T, which defaults to ComplexF32. The matrices are normalized to have unit Hilbert-Schmidt norm. The identity matrix is returned when j == 0.\n\nExamples\n\njulia> Z_matrix(0, 3)\n3×3 Matrix{ComplexF32}:\n 0.57735+0.0im      0.0+0.0im      0.0+0.0im\n     0.0+0.0im  0.57735+0.0im      0.0+0.0im\n     0.0+0.0im      0.0+0.0im  0.57735+0.0im\n\njulia> Z_matrix(1, 3)\n3×3 Matrix{ComplexF32}:\n 0.707107+0.0im        0.0+0.0im  0.0+0.0im\n      0.0+0.0im  -0.707107+0.0im  0.0+0.0im\n      0.0+0.0im        0.0+0.0im  0.0+0.0im\n\njulia> Z_matrix(2, 3)\n3×3 Matrix{ComplexF32}:\n 0.408248+0.0im       0.0+0.0im        0.0+0.0im\n      0.0+0.0im  0.408248+0.0im        0.0+0.0im\n      0.0+0.0im       0.0+0.0im  -0.816497+0.0im\n\n\n\n\n\n","category":"function"},{"location":"api/#BayesianTomography.gell_mann_matrices","page":"API","title":"BayesianTomography.gell_mann_matrices","text":"gell_mann_matrices(d, ::Type{T}=ComplexF32; include_identity=true) where {T<:Complex}\n\nGenerate a set of Gell-Mann matrices of dimension d. \n\nThe Gell-Mann matrices are a set of d^2 - 1 linearly independent, traceless,  Hermitian matrices that, when augmented with the identity, form a basis for the space of d × d hermitian matrices.\n\nThe matrix order is real off-diagonal (X_matrix),  imaginary off-diagonal (Y_matrix) and diagonal (Z_matrix). The off-diagonal matrices follow the order given by triangular_indices.\n\nArguments\n\nd: The dimension of the Gell-Mann matrices.\ninclude_identity: A boolean flag indicating whether to include the identity matrix in the set. If this is true, the identity is the first element of the basis\n\nReturns\n\nA 3D array of Gell-Mann matrices. The last dimension is the index of the matrix in the basis.\n\nExamples\n\njulia> gell_mann_matrices(2,include_identity=false)\n2×2×3 Array{ComplexF32, 3}:\n[:, :, 1] =\n      0.0+0.0im  0.707107+0.0im\n 0.707107+0.0im       0.0+0.0im\n\n[:, :, 2] =\n 0.0+0.0im       0.0-0.707107im\n 0.0+0.707107im  0.0+0.0im\n\n[:, :, 3] =\n 0.707107+0.0im        0.0+0.0im\n      0.0+0.0im  -0.707107+0.0im\n\n\n\n\n\n","category":"function"},{"location":"api/#BayesianTomography.basis_decomposition","page":"API","title":"BayesianTomography.basis_decomposition","text":"basis_decomposition(Ω, basis=gell_mann_matrices(d))\n\nDecompose the array Ω in the provided orthonormal basis.\n\nIf no basis is provided, the Gell-Mann matrices of appropriate dimension are used.\n\nIf Ω has dimension d, then basis should be an array with dimesnion d+1 with the last  dimension indexing the basis elements.\n\n\n\n\n\n","category":"function"},{"location":"api/#Representations","page":"API","title":"Representations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"History\nreduced_representation(::Array{T,N}) where {T,N}\nreduced_representation(::History)\ncomplete_representation(::Matrix{T}, ::Any) where {T}\ncomplete_representation(::History{T}, ::Any) where {T}","category":"page"},{"location":"api/#BayesianTomography.History","page":"API","title":"BayesianTomography.History","text":"History{T<:Integer}\n\nA type that represents a history of outcomes.\n\nFields\n\nhistory::Vector{T}: A vector of outcomes. history[i] is the outcome of the i-th measurement.\n\n\n\n\n\n","category":"type"},{"location":"api/#BayesianTomography.reduced_representation-Union{Tuple{Array{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"API","title":"BayesianTomography.reduced_representation","text":"reduced_representation(outcomes::Array{T,N}) where {T,N}\n\nConverts a multi-dimensional array of outcomes into a 2D matrix in  which the first row contains the indices of non-zero elements and the  second row contains the corresponding non-zero values.\n\noutcomes is a multi-dimensional array of outcomes where the outcomes[n] is  the number of times the n-th outcome was observed.\n\nThe output is a matrix where the first row contains the indices of non-zero elements  from the outcomes array and the second  row contains the corresponding non-zero values.\n\nThis function has an inverse complete_representation.\n\nExamples\n\njulia> outcomes = [0, 1, 0, 2, 0, 3]\n6-element Vector{Int64}:\n 0\n 1\n 0\n 2\n 0\n 3\n\njulia> reduced_representation(outcomes)\n2×3 Matrix{Int64}:\n 2  4  6\n 1  2  3\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianTomography.reduced_representation-Tuple{History}","page":"API","title":"BayesianTomography.reduced_representation","text":"reduced_representation(history::History)\n\nCreate a reduced representation of the given history.\n\nArguments\n\nhistory::History: A History object which contains a history of events.\n\nReturn a matrix where each column is a pair (event, count).  The event is the unique event from the history and count is the number of times the event has occurred.\n\nExample\n\njulia> h = History([1,1,1,2,1])\nHistory{Int64}([1, 1, 1, 2, 1])\n\njulia> reduced_representation(h)\n2×2 Matrix{Int64}:\n 2  1\n 1  4\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianTomography.complete_representation-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T","page":"API","title":"BayesianTomography.complete_representation","text":"complete_representation(outcomes::Matrix{T}, size) where {T}\n\nCreate a complete representation of the given outcomes.\n\noutcomes is a matrix where the first row contains the indices of non-zero elements  from of the complete representation and the second row contains the corresponding non-zero values.\n\nReturns a vector of size size where the i-th element is the value of the pair whose index is i in outcomes.  If there is no such pair, the value is 0.\n\nThis function has an inverse reduced_representation.\n\nExample\n\njulia> outcomes = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> complete_representation(outcomes, (2,2))\n2×2 Matrix{Int64}:\n 3  0\n 4  0\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianTomography.complete_representation-Union{Tuple{T}, Tuple{History{T}, Any}} where T","page":"API","title":"BayesianTomography.complete_representation","text":"complete_representation(history::History{T}, size) where {T}\n\nCreate a complete representation of the given history.\n\nArguments\n\nhistory::History: A History object which contains a history of outcomes.\nsize: The size of the resulting representation.\n\nReturns\n\nresult: An array of size size where the i-th element is the number of times the i-th event occurred in the history.\n\nExample\n\njulia> h = History([1,1,1,2,1])\nHistory{Int64}([1, 1, 1, 2, 1])\n\njulia> complete_representation(h,(2,2))\n2×2 Matrix{Int64}:\n 4  0\n 1  0\n\n\n\n\n\n","category":"method"},{"location":"api/#Samplers","page":"API","title":"Samplers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"sample\nHaarUnitary\nHaarVector\nSimplex\nProductMeasure\nGinibreEnsamble","category":"page"},{"location":"api/#BayesianTomography.sample","page":"API","title":"BayesianTomography.sample","text":"sample(type, n_samples)\nsample(type)\n\nSample n_samples from type.\n\nIf n_samples is not provided, a single sample is returned.\n\nPossible values for type are HaarUnitary, HaarVector, Simplex, ProductMeasure, and GinibreEnsamble.\n\n\n\n\n\n","category":"function"},{"location":"api/#BayesianTomography.HaarUnitary","page":"API","title":"BayesianTomography.HaarUnitary","text":"HaarUnitary(dim::Int)\n\nA type representing a Haar-random unitary matrix of dimension dim.\n\n\n\n\n\n","category":"type"},{"location":"api/#BayesianTomography.HaarVector","page":"API","title":"BayesianTomography.HaarVector","text":"HaarVector(dim::Int)\n\nA type representing a Haar-random unitary vector of dimension dim.\n\n\n\n\n\n","category":"type"},{"location":"api/#BayesianTomography.Simplex","page":"API","title":"BayesianTomography.Simplex","text":"Simplex(dim::Int)\n\nA type representing a random point on the simplex embeded in a space of dimension dim.\n\n\n\n\n\n","category":"type"},{"location":"api/#BayesianTomography.ProductMeasure","page":"API","title":"BayesianTomography.ProductMeasure","text":"ProductMeasure(dim::Int)\n\nA type representing a measure on the density states. It is a product Haar measure on the unitary group and a uniform (Lebesgue) measure on the simplex.\n\n\n\n\n\n","category":"type"},{"location":"api/#BayesianTomography.GinibreEnsamble","page":"API","title":"BayesianTomography.GinibreEnsamble","text":"GinibreEnsamble(dim::Int)\n\nA type representing a Ginibre ensamble of complex matrices of dimension dim.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation","page":"API","title":"Simulation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"simulate_outcomes\nsimulate_outcomes!","category":"page"},{"location":"api/#BayesianTomography.simulate_outcomes","page":"API","title":"BayesianTomography.simulate_outcomes","text":"simulate_outcomes(ψ::AbstractVector, povm, N; atol=1e-3)\nsimulate_outcomes(ρ::AbstractMatrix, povm, N; atol=1e-3)\nsimulate_outcomes(probs, N; atol=1e-3)\n\nSimulate the N outcomes of a quantum measurement represented by a povm on a quantum state.\n\nThe state can be pure or mixed, and it is represented by a vector ψ or a density matrix ρ, respectively. Alternativelly, one can directly provide the probabilities of the outcomes in the probs array.\n\natol is the absolute tolerance for the probabilities to be considered non-negative and to sum to 1.\n\n\n\n\n\n","category":"function"},{"location":"api/#BayesianTomography.simulate_outcomes!","page":"API","title":"BayesianTomography.simulate_outcomes!","text":"simulate_outcomes!(probs, N; atol=1e-3)\n\nSimulate the N outcomes of a probability specified by the probs array. The results are stored in the probs array.\n\natol is the absolute tolerance for the probabilities to be considered non-negative and to sum to 1.\n\n\n\n\n\n","category":"function"},{"location":"api/#Misc","page":"API","title":"Misc","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"fidelity\nproject2density\nproject2pure\northogonal_projection\nreal_orthogonal_projection\nlinear_combination\nlinear_combination!\nisposdef!(::Any,::Any,::Any)\ncond\nmaximally_mixed_state","category":"page"},{"location":"api/#BayesianTomography.fidelity","page":"API","title":"BayesianTomography.fidelity","text":"fidelity(ρ::AbstractMatrix, σ::AbstractMatrix)\nfidelity(ψ::AbstractVector, φ::AbstractVector)\n\nCalculate the fidelity between two quantum states.\n\nThe states can be pure or mixed, and they are represented by vectors ψ and φ or density matrices ρ and σ, respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#BayesianTomography.project2density","page":"API","title":"BayesianTomography.project2density","text":"project2density(ρ)\n\nProject a Hermitian matrix ρ to a density matrix by setting the negative eigenvalues to zero and normalizing the trace to 1.\n\n\n\n\n\n","category":"function"},{"location":"api/#BayesianTomography.project2pure","page":"API","title":"BayesianTomography.project2pure","text":"project2pure(ρ)\n\nProject a Hermitian matrix ρ to a pure state by returning the eigenvector corresponding to the largest eigenvalue.\n\n\n\n\n\n","category":"function"},{"location":"api/#BayesianTomography.orthogonal_projection","page":"API","title":"BayesianTomography.orthogonal_projection","text":"orthogonal_projection(ρ, set)\n\nCalculate the orthogonal projection of ρ onto set.\n\nset is an array with one more dimension than ρ.\n\n\n\n\n\n","category":"function"},{"location":"api/#BayesianTomography.real_orthogonal_projection","page":"API","title":"BayesianTomography.real_orthogonal_projection","text":"real_orthogonal_projection(ρ, set)\n\nCalculate the real part of the orthogonal projection of ρ onto set.\n\nset is an array with one more dimension than ρ.\n\nThis function is useful when the projection is expected to be real, but numerical errors may introduce small imaginary parts.\n\n\n\n\n\n","category":"function"},{"location":"api/#BayesianTomography.linear_combination","page":"API","title":"BayesianTomography.linear_combination","text":"linear_combination(xs, set)\n\nCalculate the linear combination of the elements of set with the coefficients xs.\n\n\n\n\n\n","category":"function"},{"location":"api/#BayesianTomography.linear_combination!","page":"API","title":"BayesianTomography.linear_combination!","text":"linear_combination!(ρ, xs, set)\n\nCalculate the linear combination of the elements of set with the coefficients xs and store the result in ρ.\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.isposdef!-Tuple{Any, Any, Any}","page":"API","title":"LinearAlgebra.isposdef!","text":"isposdef!(ρ, xs, set)\n\nCalculate the linear combination of the elements of set with the coefficients xs and check if the result is a positive definite matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.cond","page":"API","title":"LinearAlgebra.cond","text":"cond(M, p::Real=2)\n\nCondition number of the matrix M, computed using the operator p-norm. Valid values for p are 1, 2 (default), or Inf.\n\n\n\n\n\ncond(povm::Union{AbstractArray{T},AbstractMatrix{T}}, p::Real=2) where {T<:AbstractMatrix}\n\nCalculate the condition number of the linear transformation associated with the povm.\n\n\n\n\n\n","category":"function"},{"location":"api/#BayesianTomography.maximally_mixed_state","page":"API","title":"BayesianTomography.maximally_mixed_state","text":"maximally_mixed_state(d, ::Type{T}) where {T}\n\nReturns the maximally mixed state of dimension d, represented as a vector of projections in the generalized Gell-Mann basis.\n\nThe maximally mixed state is defined as ρ = I / d.\n\nSe also gell_mann_matrices.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Basic-Usage","page":"Basic Usage","title":"Basic Usage","text":"","category":"section"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"Possibly the simplest setup for quantum state tomography is the tomography of the polarization state of a single photon, as illustrated bellow.","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"(Image: Polarization Setup)","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"The following code snippet demonstrates how this can be modeled in the package:","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"import Random #hide\nRandom.seed!(1234) #hide\nusing BayesianTomography\n\nbs_povm = [[1.0+im 0; 0 0], [0 0; 0 1]] #POVM for a polarazing beam splitter\nhalf_wave_plate = [1 1; 1 -1] / √2 #Unitary matrix for a half-wave plate\nquarter_wave_plate = [1 im; im 1] / √2 #Unitary matrix for a quarter-wave plate\n\n\"\"\"Augment the bs_povm with the action of half-wave plate and the quarter-wave plate. \nThis is done because a single PBS is not enough to measure the polarization state of a photon.\"\"\"\npovm = augment_povm(bs_povm, half_wave_plate, quarter_wave_plate, \n                        weights=[1 / 2, 1 / 4, 1 / 4])\n\n#Generate a random quantum state to be used as an example.\nρ = sample(ProductMeasure(2))\n\n#Linear inversion method\nmthd = LinearInversion(povm)\n\n#Simulate outcomes\n#Note that we need a large number of outcomes for this method to work well.\noutcomes = simulate_outcomes(ρ, povm, 10^6) \nσ = prediction(outcomes, mthd) #Make a prediction\nfidelity(ρ, σ) #Calculate the fidelity","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"Let us break down the code snippet. First, one need to specify the measurement that is being performed. We do that by specifying a Postive Operator Value Measure (POVM), which is a collection of positive semi-definite matrices that sum to the identity. Each matrix F corresponds to a measurement outcome in such a way that the probability of obtaining a given outcome is given by the Born rule textTr rho F, where rho is the quantum state. In this package, any kind of collection of matrices can be used as a POVM, as long as they satisfy the POVM condition.","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"An example of a POVM is the one performed by a polarizing beam splitter (PBS):","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"bs_povm = [[1.0+im 0; 0 0], [0 0; 0 1]] #POVM for a polarazing beam splitter","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"This POVM has two outcomes, corresponding to the vertical and horizontal polarizations. Nonetheless, this POVM is not enough to completely determine an arbitrary state (it is called informationally incomplete). To do that, we need to add the action of a half-wave plate and a quarter-wave plate to the POVM. This is done by the augment_povm function:","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"half_wave_plate = [1 1; 1 -1] / √2 #Unitary matrix for a half-wave plate\nquarter_wave_plate = [1 im; im 1] / √2 #Unitary matrix for a quarter-wave plate\n\n\"\"\"Augment the bs_povm with the action of half-wave plate and the quarter-wave plate. \nThis is done because a single PBS is not enough to measure the polarization state of a photon.\"\"\"\npovm = augment_povm(bs_povm, half_wave_plate, quater_wave_plate, \n                        weights=[1 / 2, 1 / 4, 1 / 4])","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"The half-wave and quarter-wave plates are represented by a unitary, and the POVM is augmented by the action Fmapsto U^dagger F U of these unitaries. The weights argument specifies the weight given for each POVM. In this case, the photons going to PBS1 only pass in through a single BS, which corresponds to a probability of 12. The photons going to PBS2 and PBS3 pass in two BSs, which corresponds to a probability of 14 for each.","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"Now, we can sample a random quantum state from the ProductMeasure to be used as an example:","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"ρ = sample(ProductMeasure(2))","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"The next step is to choose a method to perform the tomography. The package provides two methods: the linear inversion method and the Bayesian inference method. The linear inversion method is the simplest and fastest method, but it assumes the knowledge of the probability of every experimental outcome, which can only be estimated with a large number of observations. The linear inversion method is chosen by creating a LinearInversion type:","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"mthd = LinearInversion(povm)","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"Now, we simulate the outcomes of the experiment:","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"outcomes = simulate_outcomes(ρ, povm, 10^6) ","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"Finally, we make a prediction of the quantum state using the prediction function, and compare it with the true state using the fidelity:","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"σ = prediction(outcomes, mthd)\nfidelity(ρ, σ)","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"We can use the BayesianInference method to perform the same task, which is able to deal with fewer observations:","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"using Random\nRandom.seed!(1234)\nusing BayesianTomography\n\nbs_povm = [[1.0+im 0; 0 0], [0 0; 0 1]]\nhalf_wave_plate = [1 1; 1 -1] / √2\nquarter_wave_plate = [1 im; im 1] / √2\n\npovm = augment_povm(bs_povm, half_wave_plate, quarter_wave_plate, \n                        weights=[1 / 2, 1 / 4, 1 / 4])\n","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"ρ = sample(ProductMeasure(2))\noutcomes = simulate_outcomes(ρ, povm, 10^3) \nmthd = BayesianInference(povm)\nσ, _ = prediction(outcomes, mthd)\nfidelity(ρ, σ)","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"We could study the effect of the number of observations on the fidelity of the estimation:","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"using Statistics, Plots\n\nobs = [2^j for j in 5:12]\nfids = Array{Float32}(undef, length(obs), 100)\nfor k in axes(fids,2)\n    for (j,obs) in enumerate(obs)\n        ρ = sample(ProductMeasure(2))\n        outcomes = simulate_outcomes(ρ, povm, obs)\n        σ, _ = prediction(outcomes, mthd)\n        fids[j,k] = fidelity(ρ, σ)\n    end\nend\n\nplot(obs, mean(fids, dims=2); \n    ribbon=std(fids, dims=2), \n    xlabel=\"Number of Observations\", \n    ylabel=\"Mean Fidelity\", \n    label = false,\n    xaxis=:log2,\n    xticks=obs,\n    yticks = .9:.01:1,\n    linewidth=3)","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"As suggested by the call σ, _ = prediction(outcomes, mthd), the Bayesian inference method returns more values. By calling it as σ, xs, Σ  = prediction(outcomes, mthd), we get the projection xs of the quantum state in the space of the generalized Gell-Mann matrices, and the associated covariance matrix Σ. This can be used to calculate the error bars of the estimation, for example:","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"using FiniteDifferences, LinearAlgebra\n\n# Extended fidelity function that takes the projection xs as input\nfunction BayesianTomography.fidelity(xs::AbstractVector, ρ::AbstractMatrix, method)\n    # method.basis is the basis of the projection\n    σ = linear_combination(xs, method.basis)\n    fidelity(ρ, σ)\nend\n\n# Gradient of the fidelity function using finite differences\nfunction ∇fidelity(xs::AbstractVector, ρ::AbstractMatrix, method)\n    f = x -> fidelity(x, ρ, method)\n    grad(central_fdm(5, 1), f, xs)[1]\nend\n\nρ = sample(ProductMeasure(2))\noutcomes = simulate_outcomes(ρ, povm, 100)\nmthd = BayesianInference(povm)\nσ, xs, Σ = prediction(outcomes, mthd)\n\n# Calculate the gradient of the fidelity function\n∇f = ∇fidelity(xs, ρ, mthd)\n\n# Calculate the uncertainty in the prediction\ndot(∇f, Σ, ∇f)","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/#POVMs","page":"Theory","title":"POVMs","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let textHer(mathcalH) subset mathcalH be the set of hermitian operators acting on a Hilbert space mathcalH. Elements of textHer(mathcalH) may be written as double kets:  F rangle  rangle. Such a space is also a real Hilbert space under the inner product","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"langle  langle E  F rangle  rangle= textTr E^dagger F = textTr E F","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The state of a quantum system is represented by an element rho of the set of positive semi-definite operators textPos(mathcalH) subset textHer(mathcalH) such that textTr rho = 1. Observables are represented by elements A in textHer(mathcalH) so that its expectation value is given by langle A rangle = langle  langle A  rho rangle  rangle. A Positive Operator Valued Measure (POVM) is a set of observables F_m subset textPos(mathcalH) with the property that sum_m F_m = I, where I is the identity operator. These operators model the possible outcomes of an experiment: outcome m happens with probability p(m) = langle  langle F_m  rho rangle  rangle. The POVM conditions ensure that p(m) ge 0 and sum_m p(m) = 1.","category":"page"},{"location":"theory/#Linear-Inversion","page":"Theory","title":"Linear Inversion","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The simplest method which solves the problem of quantum state tomography is linear inversion, which we describe in what follows. A POVM with M elements induces a linear map T textHer(mathcalH) to mathbbR^M defined by the expression","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"T Omega rangle  rangle = left(langle  langle F_1  Omega rangle  rangleldotslangle  langle F_M  Omega rangle  rangleright)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In order to be suitable for tomography, we want that the measurement probabilities mathbfp = T  rho rangle  rangle uniquely determine the state  rho rangle  rangle. This is assured if the transformation T is injective. A POVM with this property is said to be informationally complete.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"By choosing a basis Omega_n subset textHer(mathcalH), we can specify an arbitrary state  rho rangle  rangle by a list of coefficients mathbfx = (x_1ldotsx_N) such that  rho rangle  rangle = sum_n x_n  Omega_n rangle  rangle. Then, denoting by mathbbT the matrix of T with respect to the canonical basis of mathbbR^M and Omega_m, which has entries mathbbT_mn = langle  langle F_m  Omega_n rangle  rangle, we have mathbfp = mathbbTmathbfx. When mathbbT is injective, mathbbT^daggermathbbT is invertible, and then we can explicitly write the solution of the above equation as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathbfx = (mathbbT^daggermathbbT)^-1 mathbbT^dagger mathbfp","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"which, in theory, solves the tomography problem.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Note that, to apply this method, one needs a reliable estimate of the probabilities mathbfp. This can only be obtained by performing a large number of measurements.","category":"page"},{"location":"theory/#Bayesian-tomography","page":"Theory","title":"Bayesian tomography","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Bayesian tomography is the application of Bayesian inference to the problem of quantum state tomography [1]. The goal is to estimate the posterior distribution of the quantum state given the observed data. The posterior distribution is given by Bayes' theorem","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"P(rho  mathcalM) = fracP(mathcalM  rho) P(rho)P(mathcalM)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where P(mathcalM  rho) is the likelihood of the observations mathcalM given the state, P(rho) is the prior distribution of the state, and P(mathcalM) is the evidence. In the case of quantum state tomography, the likelihood is given by the Born rule ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"P(mathcalM  rho) = prod_m p(m)^n_m    p(m) = langle  langle F_m  rho rangle  rangle","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where n_m is the number of times outcome m was observed. The prior distribution is a probability distribution over the space of states, which encodes any prior knowledge about the state. The evidence is the normalization constant, given by P(mathcalM) = int P(mathcalM  rho) P(rho) drho.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Bayesian inference does not provide a single estimate of the state, but a full distribution. The mean of the distribution is, in a sense, the best estimate of the state [1], and the variance gives an idea of the uncertainty of the estimate. Directly calculating the posterior distribution is infeasible, as it requires the computation of the evidence, which is a high-dimensional integral. The alternative is to sample the posterior distribution using Markov Chain Monte Carlo (MCMC) methods. The package provides an implementation of the Metropolis Adjusted Langevin Algorithm (MALA) [2] [3] to sample the posterior distribution.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"As shown in the video above, MALA generates a random walk in the space of valid density operators (we reject all proposals falling outside this set) whose statistics are given by the desired posterior distribution.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[1]: Blume-Kohout, Robin. \"Optimal, reliable estimation of quantum states.\" New Journal of Physics 12.4 (2010): 043034.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[2]: Karagulyan, Avetik. Sampling with the Langevin Monte-Carlo. Diss. Institut polytechnique de Paris, 2021.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[3]: Titsias, Michalis. \"Optimal Preconditioning and Fisher Adaptive Langevin Sampling.\" Advances in Neural Information Processing Systems 36 (2024).","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides tools to perform quantum state tomography. It is designed to be flexible and easy to use, with a focus on providing a simple interface for common tasks. As its name suggests, its flagship feature is the ability to perform Bayesian quantum state tomography, but it also provides an interface for the simple linear inversion method.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package is almost registered in the Julia General registry and can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run add BayesianTomography.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"index.md\", \"usage.md\", \"theory.md\", \"api.md\"]","category":"page"}]
}
