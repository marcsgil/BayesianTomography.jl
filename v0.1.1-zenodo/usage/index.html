<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic Usage · BayesianTomography.jl</title><meta name="title" content="Basic Usage · BayesianTomography.jl"/><meta property="og:title" content="Basic Usage · BayesianTomography.jl"/><meta property="twitter:title" content="Basic Usage · BayesianTomography.jl"/><meta name="description" content="Documentation for BayesianTomography.jl."/><meta property="og:description" content="Documentation for BayesianTomography.jl."/><meta property="twitter:description" content="Documentation for BayesianTomography.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BayesianTomography.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Basic Usage</a></li><li><a class="tocitem" href="../theory/">Theory</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Basic Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basic Usage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/marcsgil/BayesianTomography.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/marcsgil/BayesianTomography.jl/blob/main/docs/src/usage.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h1><p>Possibly the simplest setup for quantum state tomography is the tomography of the polarization state of a single photon, as illustrated bellow.</p><p><img src="../assets/polarization_setup.jpeg" alt="Polarization Setup"/></p><p>The following code snippet demonstrates how this can be modeled in the package:</p><pre><code class="language-julia hljs">using BayesianTomography

bs_povm = [[1.0+im 0; 0 0], [0 0; 0 1]] #POVM for a polarazing beam splitter
half_wave_plate = [1 1; 1 -1] / √2 #Unitary matrix for a half-wave plate
quarter_wave_plate = [1 im; im 1] / √2 #Unitary matrix for a quarter-wave plate

&quot;&quot;&quot;Augment the bs_povm with the action of half-wave plate and the quarter-wave plate.
This is done because a single PBS is not enough to measure the polarization state of a photon.&quot;&quot;&quot;
povm = augment_povm(bs_povm, half_wave_plate, quarter_wave_plate,
                        weights=[1 / 2, 1 / 4, 1 / 4])

#Generate a random quantum state to be used as an example.
ρ = sample(ProductMeasure(2))

#Linear inversion method
mthd = LinearInversion(povm)

#Simulate outcomes
#Note that we need a large number of outcomes for this method to work well.
outcomes = simulate_outcomes(ρ, povm, 10^6)
σ = prediction(outcomes, mthd) #Make a prediction
fidelity(ρ, σ) #Calculate the fidelity</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9999997826936539</code></pre><p>Let us break down the code snippet. First, one need to specify the measurement that is being performed. We do that by specifying a Postive Operator Value Measure (POVM), which is a collection of positive semi-definite matrices that sum to the identity. Each matrix <span>$F$</span> corresponds to a measurement outcome in such a way that the probability of obtaining a given outcome is given by the Born rule <span>$\text{Tr} \rho F$</span>, where <span>$\rho$</span> is the quantum state. In this package, any kind of collection of matrices can be used as a POVM, as long as they satisfy the POVM condition.</p><p>An example of a POVM is the one performed by a polarizing beam splitter (PBS):</p><pre><code class="language-julia hljs">bs_povm = [[1.0+im 0; 0 0], [0 0; 0 1]] #POVM for a polarazing beam splitter</code></pre><p>This POVM has two outcomes, corresponding to the vertical and horizontal polarizations. Nonetheless, this POVM is not enough to completely determine an arbitrary state (it is called informationally incomplete). To do that, we need to add the action of a half-wave plate and a quarter-wave plate to the POVM. This is done by the <a href="../api/#BayesianTomography.augment_povm"><code>augment_povm</code></a> function:</p><pre><code class="language-julia hljs">half_wave_plate = [1 1; 1 -1] / √2 #Unitary matrix for a half-wave plate
quarter_wave_plate = [1 im; im 1] / √2 #Unitary matrix for a quarter-wave plate

&quot;&quot;&quot;Augment the bs_povm with the action of half-wave plate and the quarter-wave plate. 
This is done because a single PBS is not enough to measure the polarization state of a photon.&quot;&quot;&quot;
povm = augment_povm(bs_povm, half_wave_plate, quater_wave_plate, 
                        weights=[1 / 2, 1 / 4, 1 / 4])</code></pre><p>The half-wave and quarter-wave plates are represented by a unitary, and the POVM is augmented by the action <span>$F\mapsto U^\dagger F U$</span> of these unitaries. The <code>weights</code> argument specifies the weight given for each POVM. In this case, the photons going to PBS1 only pass in through a single BS, which corresponds to a probability of <span>$1/2$</span>. The photons going to PBS2 and PBS3 pass in two BSs, which corresponds to a probability of <span>$1/4$</span> for each.</p><p>Now, we can <a href="../api/#BayesianTomography.sample"><code>sample</code></a> a random quantum state from the <a href="../api/#BayesianTomography.ProductMeasure"><code>ProductMeasure</code></a> to be used as an example:</p><pre><code class="language-julia hljs">ρ = sample(ProductMeasure(2))</code></pre><p>The next step is to choose a method to perform the tomography. The package provides two methods: the linear inversion method and the Bayesian inference method. The linear inversion method is the simplest and fastest method, but it assumes the knowledge of the probability of every experimental outcome, which can only be estimated with a large number of observations. The linear inversion method is chosen by creating a <a href="../api/#BayesianTomography.LinearInversion"><code>LinearInversion</code></a> type:</p><pre><code class="language-julia hljs">mthd = LinearInversion(povm)</code></pre><p>Now, we simulate the outcomes of the experiment:</p><pre><code class="language-julia hljs">outcomes = simulate_outcomes(ρ, povm, 10^6) </code></pre><p>Finally, we make a prediction of the quantum state using the <a href="../api/#BayesianTomography.prediction-Tuple{Any, LinearInversion}"><code>prediction</code></a> function, and compare it with the true state using the <a href="../api/#BayesianTomography.fidelity"><code>fidelity</code></a>:</p><pre><code class="language-julia hljs">σ = prediction(outcomes, mthd)
fidelity(ρ, σ)</code></pre><p>We can use the <a href="../api/#BayesianTomography.BayesianInference"><code>BayesianInference</code></a> method to perform the same task, which is able to deal with fewer observations:</p><pre><code class="language-julia hljs">ρ = sample(ProductMeasure(2))
outcomes = simulate_outcomes(ρ, povm, 10^3)
mthd = BayesianInference(povm)
σ, _ = prediction(outcomes, mthd)
fidelity(ρ, σ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9929541086586184</code></pre><p>We could study the effect of the number of observations on the fidelity of the estimation:</p><pre><code class="language-julia hljs">using Statistics, Plots

obs = [2^j for j in 5:12]
fids = Array{Float32}(undef, length(obs), 100)
for k in axes(fids,2)
    for (j,obs) in enumerate(obs)
        ρ = sample(ProductMeasure(2))
        outcomes = simulate_outcomes(ρ, povm, obs)
        σ, _ = prediction(outcomes, mthd)
        fids[j,k] = fidelity(ρ, σ)
    end
end

plot(obs, mean(fids, dims=2);
    ribbon=std(fids, dims=2),
    xlabel=&quot;Number of Observations&quot;,
    ylabel=&quot;Mean Fidelity&quot;,
    label = false,
    xaxis=:log2,
    xticks=obs,
    yticks = .9:.01:1,
    linewidth=3)</code></pre><img src="553fe9bf.svg" alt="Example block output"/><p>As suggested by the call <code>σ, _ = prediction(outcomes, mthd)</code>, the Bayesian inference method returns more values. By calling it as <code>σ, xs, Σ  = prediction(outcomes, mthd)</code>, we get the projection <code>xs</code> of the quantum state in the space of the generalized Gell-Mann matrices, and the associated covariance matrix <code>Σ</code>. This can be used to calculate the error bars of the estimation, for example:</p><pre><code class="language-julia hljs">using FiniteDifferences, LinearAlgebra

# Extended fidelity function that takes the projection xs as input
function BayesianTomography.fidelity(xs::AbstractVector, ρ::AbstractMatrix, method)
    # method.basis is the basis of the projection
    σ = linear_combination(xs, method.basis)
    fidelity(ρ, σ)
end

# Gradient of the fidelity function using finite differences
function ∇fidelity(xs::AbstractVector, ρ::AbstractMatrix, method)
    f = x -&gt; fidelity(x, ρ, method)
    grad(central_fdm(5, 1), f, xs)[1]
end

ρ = sample(ProductMeasure(2))
outcomes = simulate_outcomes(ρ, povm, 100)
mthd = BayesianInference(povm)
σ, xs, Σ = prediction(outcomes, mthd)

# Calculate the gradient of the fidelity function
∇f = ∇fidelity(xs, ρ, mthd)

# Calculate the uncertainty in the prediction
dot(∇f, Σ, ∇f)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0007614372204148306</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../theory/">Theory »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Saturday 6 April 2024 16:07">Saturday 6 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
