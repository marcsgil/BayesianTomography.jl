<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · BayesianTomography.jl</title><meta name="title" content="API · BayesianTomography.jl"/><meta property="og:title" content="API · BayesianTomography.jl"/><meta property="twitter:title" content="API · BayesianTomography.jl"/><meta name="description" content="Documentation for BayesianTomography.jl."/><meta property="og:description" content="Documentation for BayesianTomography.jl."/><meta property="twitter:description" content="Documentation for BayesianTomography.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BayesianTomography.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../usage/">Basic Usage</a></li><li><a class="tocitem" href="../theory/">Theory</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Prediction"><span>Prediction</span></a></li><li><a class="tocitem" href="#Augmentation"><span>Augmentation</span></a></li><li><a class="tocitem" href="#Generalized-Gell-Mann-matrices"><span>Generalized Gell-Mann matrices</span></a></li><li><a class="tocitem" href="#Representations"><span>Representations</span></a></li><li><a class="tocitem" href="#Samplers"><span>Samplers</span></a></li><li><a class="tocitem" href="#Simulation"><span>Simulation</span></a></li><li><a class="tocitem" href="#Misc"><span>Misc</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/marcsgil/BayesianTomography.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/marcsgil/BayesianTomography.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Prediction"><a class="docs-heading-anchor" href="#Prediction">Prediction</a><a id="Prediction-1"></a><a class="docs-heading-anchor-permalink" href="#Prediction" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.prediction-Tuple{Any, LinearInversion}" href="#BayesianTomography.prediction-Tuple{Any, LinearInversion}"><code>BayesianTomography.prediction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prediction(outcomes, method::LinearInversion)</code></pre><p>Predict the quantum state from the outcomes of a tomography experiment using the <a href="#BayesianTomography.LinearInversion"><code>LinearInversion</code></a> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/linear_inversion.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.prediction-Tuple{Any, BayesianInference}" href="#BayesianTomography.prediction-Tuple{Any, BayesianInference}"><code>BayesianTomography.prediction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prediction(outcomes, method::BayesianInference{T};
    verbose=false,
    σ=T(1e-2),
    log_prior=x -&gt; zero(T),
    x₀=maximally_mixed_state(Int(√size(method.povm, 2)), T),
    nsamples=10^4,
    nwarm=10^3,
    chain=nothing) where {T}</code></pre><p>Perform a Bayesian inference on the given <code>outcomes</code> using the <a href="#BayesianTomography.BayesianInference"><code>BayesianInference</code></a> <code>method</code>.</p><p><strong>Arguments</strong></p><ul><li><code>outcomes</code>: The outcomes of the experiment.</li><li><code>method::BayesianInference{T}</code>: The Bayesian inference method.</li><li><code>verbose=false</code>: Print information about the run.</li><li><code>σ=T(1e-2)</code>: The initial standard deviation of the proposal distribution.</li><li><code>log_prior=x -&gt; zero(T)</code>: The log-prior function.</li><li><code>x₀=maximally_mixed_state(Int(√size(method.povm, 2)), T)</code>: The initial state of the chain.</li><li><code>nsamples=10^4</code>: The number of samples to take.</li><li><code>nwarm=10^3</code>: The number of warm-up samples to take.</li><li><code>chain=nothing</code>: If not <code>nothing</code>, store the chain in this matrix.</li></ul><p><strong>Returns</strong></p><p>A tuple with the mean state, its projection in <code>method.basis</code> and the covariance matrix. The mean state is already returned in matrix form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/bayesian_inference.jl#L220-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.LinearInversion" href="#BayesianTomography.LinearInversion"><code>BayesianTomography.LinearInversion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearInversion(povm, basis=gell_mann_matrices(size(first(povm), 1)))</code></pre><p>Construct a linear inversion method for quantum state tomography.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/linear_inversion.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.BayesianInference" href="#BayesianTomography.BayesianInference"><code>BayesianTomography.BayesianInference</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BayesianInference(povm::AbstractArray{Matrix{T}},
    basis=gell_mann_matrices(size(first(povm), 1), complex(T))) where {T}</code></pre><p>Create a Bayesian inference object from a POVM.</p><p>This is passed to the <a href="#BayesianTomography.prediction-Tuple{Any, LinearInversion}"><code>prediction</code></a> method in order to perform the Bayesian inference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/bayesian_inference.jl#L180-L187">source</a></section></article><h2 id="Augmentation"><a class="docs-heading-anchor" href="#Augmentation">Augmentation</a><a id="Augmentation-1"></a><a class="docs-heading-anchor-permalink" href="#Augmentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.compose_povm" href="#BayesianTomography.compose_povm"><code>BayesianTomography.compose_povm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compose_povm(povms::AbstractArray{Matrix{T}}...; weights=fill(one(T) / length(povms), length(povms))) where {T}</code></pre><p>Compose a POVM (Positive Operator-Valued Measure) from a set of given POVMs.</p><p><strong>Arguments</strong></p><ul><li><code>povms</code>: Variable number of POVMs. Each POVM is represented as an array of matrices.</li><li><code>weights</code>: An optional array of weights associated with each POVM. If not provided, it defaults to a uniform distribution.</li></ul><p><strong>Returns</strong></p><ul><li>A new POVM that is a composition of the input POVMs, weighted by their respective weights.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">povm1 = [rand(2,2) for _ in 1:3]
povm2 = [rand(2,2) for _ in 1:3]
composed_povm = compose_povm(povm1, povm2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/augmentation.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.unitary_transform!" href="#BayesianTomography.unitary_transform!"><code>BayesianTomography.unitary_transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unitary_transform!(povm, unitary)</code></pre><p>Apply a unitary transformation to each element of a given POVM (Positive Operator-Valued Measure), modifing it in place.</p><p><strong>Arguments</strong></p><ul><li><code>povm</code>: The POVM to be transformed. It is represented as an array of matrices.</li><li><code>unitary</code>: The unitary matrix representing the transformation to be applied.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">bs_povm = [[1.0+im 0; 0 0], [0 0; 0 1]]
half_wave_plate = [1 1; 1 -1] / √2
unitary_transform!(bs_povm, half_wave_plate)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/augmentation.jl#L25-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.unitary_transform" href="#BayesianTomography.unitary_transform"><code>BayesianTomography.unitary_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unitary_transform(povm, unitary)</code></pre><p>Apply a unitary transformation to each element of a given POVM (Positive Operator-Valued Measure).</p><p><strong>Arguments</strong></p><ul><li><code>povm</code>: The POVM to be transformed. It is represented as an array of matrices.</li><li><code>unitary</code>: The unitary matrix representing the transformation to be applied.</li></ul><p><strong>Returns</strong></p><ul><li>A new POVM that is the result of applying the unitary transformation to the input POVM.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">bs_povm = [[1.0+im 0; 0 0], [0 0; 0 1]]
half_wave_plate = [1 1; 1 -1] / √2
unitary_transform!(bs_povm, half_wave_plate)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/augmentation.jl#L48-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.augment_povm" href="#BayesianTomography.augment_povm"><code>BayesianTomography.augment_povm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">augment_povm(povm::AbstractArray{Matrix{T}}, unitaries...; 
    weights=fill(one(T) / (length(unitaries) + 1), length(unitaries) + 1) where {T}</code></pre><p>Augment a POVM (Positive Operator-Valued Measure) by applying a set of unitary transformations to it.</p><p><strong>Arguments</strong></p><ul><li><code>povm</code>: The POVM to be augmented. It is represented as an array of matrices.</li><li><code>unitaries</code>: Variable number of unitary matrices representing the transformations to be applied.</li><li><code>weights</code>: An optional array of weights associated with each unitary transformation. If not provided, it defaults to a uniform distribution.</li></ul><p><strong>Returns</strong></p><ul><li>A new POVM that is the result of applying the unitary transformations to the input POVM.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">bs_povm = [[1.0+im 0; 0 0], [0 0; 0 1]]
half_wave_plate = [1 1; 1 -1] / √2
quater_wave_plate = [1 im; im 1] / √2
povm = augment_povm(bs_povm, half_wave_plate, quater_wave_plate, weights=[1 / 2, 1 / 4, 1 / 4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/augmentation.jl#L73-L94">source</a></section></article><h2 id="Generalized-Gell-Mann-matrices"><a class="docs-heading-anchor" href="#Generalized-Gell-Mann-matrices">Generalized Gell-Mann matrices</a><a id="Generalized-Gell-Mann-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-Gell-Mann-matrices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.triangular_indices" href="#BayesianTomography.triangular_indices"><code>BayesianTomography.triangular_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">triangular_indices(d)</code></pre><p>Generate a vector of tuples representing the indices of the lower triangular part of a square matrix of dimension <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/hermitian_basis.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.X_matrix" href="#BayesianTomography.X_matrix"><code>BayesianTomography.X_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">X_matrix(j, k, d, ::Type{T}=ComplexF32) where {T&lt;:Union{Real,Complex}}</code></pre><p>Compute the real off diagonal matrix of the generalized Gell-Mann matrices in dimension <code>d</code>.</p><p>The type of the matrix elements is <code>T</code>, which defaults to <code>ComplexF32</code>. The only non-zero elements are <code>X[j, k] = 1</code> and <code>X[k, j] = 1</code>. The matrices are normalized to have unit Hilbert-Schmidt norm.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X_matrix(1,2,2)
2×2 Matrix{ComplexF32}:
      0.0+0.0im  0.707107+0.0im
 0.707107+0.0im       0.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/hermitian_basis.jl#L18-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.Y_matrix" href="#BayesianTomography.Y_matrix"><code>BayesianTomography.Y_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Y_matrix(j, k, d, ::Type{T}=ComplexF32) where {T&lt;:Complex}</code></pre><p>Compute the imaginary off diagonal matrix of the generalized Gell-Mann matrices in dimension <code>d</code>.</p><p>The type of the matrix elements is <code>T</code>, which defaults to <code>ComplexF32</code>. The only non-zero elements are <code>Y[j, k] = im</code> and <code>Y[k, j] = -im</code>. The matrices are normalized to have unit Hilbert-Schmidt norm.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y_matrix(1,2,2)
2×2 Matrix{ComplexF32}:
 0.0+0.0im       0.0+0.707107im
 0.0-0.707107im  0.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/hermitian_basis.jl#L43-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.Z_matrix" href="#BayesianTomography.Z_matrix"><code>BayesianTomography.Z_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Z_matrix(j, d, ::Type{T}=ComplexF32) where {T&lt;:Union{Real,Complex}}</code></pre><p>Compute the <code>j</code>&#39;th diagonal matrix of the generalized Gell-Mann matrices in dimension <code>d</code>.</p><p>The type of the matrix elements is <code>T</code>, which defaults to <code>ComplexF32</code>. The matrices are normalized to have unit Hilbert-Schmidt norm. The identity matrix is returned when <code>j == 0</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Z_matrix(0, 3)
3×3 Matrix{ComplexF32}:
 0.57735+0.0im      0.0+0.0im      0.0+0.0im
     0.0+0.0im  0.57735+0.0im      0.0+0.0im
     0.0+0.0im      0.0+0.0im  0.57735+0.0im

julia&gt; Z_matrix(1, 3)
3×3 Matrix{ComplexF32}:
 0.707107+0.0im        0.0+0.0im  0.0+0.0im
      0.0+0.0im  -0.707107+0.0im  0.0+0.0im
      0.0+0.0im        0.0+0.0im  0.0+0.0im

julia&gt; Z_matrix(2, 3)
3×3 Matrix{ComplexF32}:
 0.408248+0.0im       0.0+0.0im        0.0+0.0im
      0.0+0.0im  0.408248+0.0im        0.0+0.0im
      0.0+0.0im       0.0+0.0im  -0.816497+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/hermitian_basis.jl#L68-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.gell_mann_matrices" href="#BayesianTomography.gell_mann_matrices"><code>BayesianTomography.gell_mann_matrices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gell_mann_matrices(d, ::Type{T}=ComplexF32; include_identity=true) where {T&lt;:Complex}</code></pre><p>Generate a set of Gell-Mann matrices of dimension <code>d</code>. </p><p>The Gell-Mann matrices are a set of <code>d^2 - 1</code> linearly independent, traceless,  Hermitian matrices that, when augmented with the identity, form a basis for the space of <code>d × d</code> hermitian matrices.</p><p>The matrix order is real off-diagonal (<a href="#BayesianTomography.X_matrix"><code>X_matrix</code></a>),  imaginary off-diagonal (<a href="#BayesianTomography.Y_matrix"><code>Y_matrix</code></a>) and diagonal (<a href="#BayesianTomography.Z_matrix"><code>Z_matrix</code></a>). The off-diagonal matrices follow the order given by <a href="#BayesianTomography.triangular_indices"><code>triangular_indices</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>d</code>: The dimension of the Gell-Mann matrices.</li><li><code>include_identity</code>: A boolean flag indicating whether to include the identity matrix in the set. If this is <code>true</code>, the identity is the first element of the basis</li></ul><p><strong>Returns</strong></p><ul><li>A 3D array of Gell-Mann matrices. The last dimension is the index of the matrix in the basis.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gell_mann_matrices(2,include_identity=false)
2×2×3 Array{ComplexF32, 3}:
[:, :, 1] =
      0.0+0.0im  0.707107+0.0im
 0.707107+0.0im       0.0+0.0im

[:, :, 2] =
 0.0+0.0im       0.0-0.707107im
 0.0+0.707107im  0.0+0.0im

[:, :, 3] =
 0.707107+0.0im        0.0+0.0im
      0.0+0.0im  -0.707107+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/hermitian_basis.jl#L112-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.basis_decomposition" href="#BayesianTomography.basis_decomposition"><code>BayesianTomography.basis_decomposition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basis_decomposition(Ω, basis=gell_mann_matrices(d))</code></pre><p>Decompose the array <code>Ω</code> in the provided orthonormal basis.</p><p>If no basis is provided, the Gell-Mann matrices of appropriate dimension are used.</p><p>If <code>Ω</code> has dimension d, then <code>basis</code> should be an array with dimesnion <code>d+1</code> with the last  dimension indexing the basis elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/hermitian_basis.jl#L169-L178">source</a></section></article><h2 id="Representations"><a class="docs-heading-anchor" href="#Representations">Representations</a><a id="Representations-1"></a><a class="docs-heading-anchor-permalink" href="#Representations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.History" href="#BayesianTomography.History"><code>BayesianTomography.History</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">History{T&lt;:Integer}</code></pre><p>A type that represents a history of outcomes.</p><p><strong>Fields</strong></p><ul><li><code>history::Vector{T}</code>: A vector of outcomes. <code>history[i]</code> is the outcome of the i-th measurement.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/representations.jl#L85-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.reduced_representation-Union{Tuple{Array{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#BayesianTomography.reduced_representation-Union{Tuple{Array{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>BayesianTomography.reduced_representation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduced_representation(outcomes::Array{T,N}) where {T,N}</code></pre><p>Converts a multi-dimensional array of outcomes into a 2D matrix in  which the first row contains the indices of non-zero elements and the  second row contains the corresponding non-zero values.</p><p><code>outcomes</code> is a multi-dimensional array of outcomes where the <code>outcomes[n]</code> is  the number of times the <code>n</code>-th outcome was observed.</p><p>The output is a matrix where the first row contains the indices of non-zero elements  from the <code>outcomes</code> array and the second  row contains the corresponding non-zero values.</p><p>This function has an inverse <a href="#BayesianTomography.complete_representation-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T"><code>complete_representation</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; outcomes = [0, 1, 0, 2, 0, 3]
6-element Vector{Int64}:
 0
 1
 0
 2
 0
 3

julia&gt; reduced_representation(outcomes)
2×3 Matrix{Int64}:
 2  4  6
 1  2  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/representations.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.reduced_representation-Tuple{History}" href="#BayesianTomography.reduced_representation-Tuple{History}"><code>BayesianTomography.reduced_representation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduced_representation(history::History)</code></pre><p>Create a reduced representation of the given history.</p><p><strong>Arguments</strong></p><ul><li><code>history::History</code>: A History object which contains a history of events.</li></ul><p>Return a matrix where each column is a pair (event, count).  The event is the unique event from the history and count is the number of times the event has occurred.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = History([1,1,1,2,1])
History{Int64}([1, 1, 1, 2, 1])

julia&gt; reduced_representation(h)
2×2 Matrix{Int64}:
 2  1
 1  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/representations.jl#L101-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.complete_representation-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T" href="#BayesianTomography.complete_representation-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T"><code>BayesianTomography.complete_representation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">complete_representation(outcomes::Matrix{T}, size) where {T}</code></pre><p>Create a complete representation of the given outcomes.</p><p><code>outcomes</code> is a matrix where the first row contains the indices of non-zero elements  from of the complete representation and the second row contains the corresponding non-zero values.</p><p>Returns a vector of size <code>size</code> where the i-th element is the value of the pair whose index is i in <code>outcomes</code>.  If there is no such pair, the value is 0.</p><p>This function has an inverse <a href="#BayesianTomography.reduced_representation-Union{Tuple{Array{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>reduced_representation</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; outcomes = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; complete_representation(outcomes, (2,2))
2×2 Matrix{Int64}:
 3  0
 4  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/representations.jl#L50-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.complete_representation-Union{Tuple{T}, Tuple{History{T}, Any}} where T" href="#BayesianTomography.complete_representation-Union{Tuple{T}, Tuple{History{T}, Any}} where T"><code>BayesianTomography.complete_representation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">complete_representation(history::History{T}, size) where {T}</code></pre><p>Create a complete representation of the given history.</p><p><strong>Arguments</strong></p><ul><li><code>history::History</code>: A History object which contains a history of outcomes.</li><li><code>size</code>: The size of the resulting representation.</li></ul><p><strong>Returns</strong></p><ul><li><code>result</code>: An array of size <code>size</code> where the i-th element is the number of times the i-th event occurred in the history.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = History([1,1,1,2,1])
History{Int64}([1, 1, 1, 2, 1])

julia&gt; complete_representation(h,(2,2))
2×2 Matrix{Int64}:
 4  0
 1  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/representations.jl#L135-L157">source</a></section></article><h2 id="Samplers"><a class="docs-heading-anchor" href="#Samplers">Samplers</a><a id="Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Samplers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.sample" href="#BayesianTomography.sample"><code>BayesianTomography.sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample(type, n_samples)
sample(type)</code></pre><p>Sample <code>n_samples</code> from <code>type</code>.</p><p>If <code>n_samples</code> is not provided, a single sample is returned.</p><p>Possible values for type are <a href="#BayesianTomography.HaarUnitary"><code>HaarUnitary</code></a>, <a href="#BayesianTomography.HaarVector"><code>HaarVector</code></a>, <a href="#BayesianTomography.Simplex"><code>Simplex</code></a>, <a href="#BayesianTomography.ProductMeasure"><code>ProductMeasure</code></a>, and <a href="#BayesianTomography.GinibreEnsamble"><code>GinibreEnsamble</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/samplers.jl#L10-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.HaarUnitary" href="#BayesianTomography.HaarUnitary"><code>BayesianTomography.HaarUnitary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HaarUnitary(dim::Int)</code></pre><p>A type representing a Haar-random unitary matrix of dimension <code>dim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/samplers.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.HaarVector" href="#BayesianTomography.HaarVector"><code>BayesianTomography.HaarVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HaarVector(dim::Int)</code></pre><p>A type representing a Haar-random unitary vector of dimension <code>dim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/samplers.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.Simplex" href="#BayesianTomography.Simplex"><code>BayesianTomography.Simplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Simplex(dim::Int)</code></pre><p>A type representing a random point on the simplex embeded in a space of dimension <code>dim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/samplers.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.ProductMeasure" href="#BayesianTomography.ProductMeasure"><code>BayesianTomography.ProductMeasure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProductMeasure(dim::Int)</code></pre><p>A type representing a measure on the density states. It is a product Haar measure on the unitary group and a uniform (Lebesgue) measure on the simplex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/samplers.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.GinibreEnsamble" href="#BayesianTomography.GinibreEnsamble"><code>BayesianTomography.GinibreEnsamble</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GinibreEnsamble(dim::Int)</code></pre><p>A type representing a Ginibre ensamble of complex matrices of dimension <code>dim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/samplers.jl#L97-L101">source</a></section></article><h2 id="Simulation"><a class="docs-heading-anchor" href="#Simulation">Simulation</a><a id="Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.simulate_outcomes" href="#BayesianTomography.simulate_outcomes"><code>BayesianTomography.simulate_outcomes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate_outcomes(ψ::AbstractVector, povm, N; atol=1e-3)
simulate_outcomes(ρ::AbstractMatrix, povm, N; atol=1e-3)
simulate_outcomes(probs, N; atol=1e-3)</code></pre><p>Simulate the <code>N</code> outcomes of a quantum measurement represented by a <code>povm</code> on a quantum state.</p><p>The state can be pure or mixed, and it is represented by a vector <code>ψ</code> or a density matrix <code>ρ</code>, respectively. Alternativelly, one can directly provide the probabilities of the outcomes in the <code>probs</code> array.</p><p><code>atol</code> is the absolute tolerance for the probabilities to be considered non-negative and to sum to 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/utils.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.simulate_outcomes!" href="#BayesianTomography.simulate_outcomes!"><code>BayesianTomography.simulate_outcomes!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate_outcomes!(probs, N; atol=1e-3)</code></pre><p>Simulate the <code>N</code> outcomes of a probability specified by the <code>probs</code> array. The results are stored in the <code>probs</code> array.</p><p><code>atol</code> is the absolute tolerance for the probabilities to be considered non-negative and to sum to 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/utils.jl#L33-L40">source</a></section></article><h2 id="Misc"><a class="docs-heading-anchor" href="#Misc">Misc</a><a id="Misc-1"></a><a class="docs-heading-anchor-permalink" href="#Misc" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.fidelity" href="#BayesianTomography.fidelity"><code>BayesianTomography.fidelity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fidelity(ρ::AbstractMatrix, σ::AbstractMatrix)
fidelity(ψ::AbstractVector, φ::AbstractVector)</code></pre><p>Calculate the fidelity between two quantum states.</p><p>The states can be pure or mixed, and they are represented by vectors <code>ψ</code> and <code>φ</code> or density matrices <code>ρ</code> and <code>σ</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/utils.jl#L54-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.project2density" href="#BayesianTomography.project2density"><code>BayesianTomography.project2density</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">project2density(ρ)</code></pre><p>Project a Hermitian matrix <code>ρ</code> to a density matrix by setting the negative eigenvalues to zero and normalizing the trace to 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/utils.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.project2pure" href="#BayesianTomography.project2pure"><code>BayesianTomography.project2pure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">project2pure(ρ)</code></pre><p>Project a Hermitian matrix <code>ρ</code> to a pure state by returning the eigenvector corresponding to the largest eigenvalue.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/utils.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.orthogonal_projection" href="#BayesianTomography.orthogonal_projection"><code>BayesianTomography.orthogonal_projection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">orthogonal_projection(ρ, set)</code></pre><p>Calculate the orthogonal projection of <code>ρ</code> onto <code>set</code>.</p><p><code>set</code> is an array with one more dimension than <code>ρ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/utils.jl#L91-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.real_orthogonal_projection" href="#BayesianTomography.real_orthogonal_projection"><code>BayesianTomography.real_orthogonal_projection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">real_orthogonal_projection(ρ, set)</code></pre><p>Calculate the real part of the orthogonal projection of <code>ρ</code> onto <code>set</code>.</p><p><code>set</code> is an array with one more dimension than <code>ρ</code>.</p><p>This function is useful when the projection is expected to be real, but numerical errors may introduce small imaginary parts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/utils.jl#L103-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.linear_combination" href="#BayesianTomography.linear_combination"><code>BayesianTomography.linear_combination</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linear_combination(xs, set)</code></pre><p>Calculate the linear combination of the elements of <code>set</code> with the coefficients <code>xs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/utils.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.linear_combination!" href="#BayesianTomography.linear_combination!"><code>BayesianTomography.linear_combination!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linear_combination!(ρ, xs, set)</code></pre><p>Calculate the linear combination of the elements of <code>set</code> with the coefficients <code>xs</code> and store the result in <code>ρ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/utils.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.isposdef!-Tuple{Any, Any, Any}" href="#LinearAlgebra.isposdef!-Tuple{Any, Any, Any}"><code>LinearAlgebra.isposdef!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isposdef!(ρ, xs, set)</code></pre><p>Calculate the linear combination of the elements of <code>set</code> with the coefficients <code>xs</code> and check if the result is a positive definite matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/utils.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.cond" href="#LinearAlgebra.cond"><code>LinearAlgebra.cond</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cond(M, p::Real=2)</code></pre><p>Condition number of the matrix <code>M</code>, computed using the operator <code>p</code>-norm. Valid values for <code>p</code> are <code>1</code>, <code>2</code> (default), or <code>Inf</code>.</p></div></section><section><div><pre><code class="language-julia hljs">cond(povm::Union{AbstractArray{T},AbstractMatrix{T}}, p::Real=2) where {T&lt;:AbstractMatrix}</code></pre><p>Calculate the condition number of the linear transformation associated with the <code>povm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/utils.jl#L148-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BayesianTomography.maximally_mixed_state" href="#BayesianTomography.maximally_mixed_state"><code>BayesianTomography.maximally_mixed_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">maximally_mixed_state(d, ::Type{T}) where {T}</code></pre><p>Returns the maximally mixed state of dimension <code>d</code>, represented as a vector of projections in the generalized Gell-Mann basis.</p><p>The maximally mixed state is defined as <code>ρ = I / d</code>.</p><p>Se also <a href="#BayesianTomography.gell_mann_matrices"><code>gell_mann_matrices</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/marcsgil/BayesianTomography.jl/blob/b0c5ed19953ec220f83536e78b2db6ab633cb4e0/src/utils.jl#L160-L168">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theory/">« Theory</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Saturday 6 April 2024 16:07">Saturday 6 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
